/* tslint:disable */
/* eslint-disable */
/**
 * Oasix API
 * This is the Oasix property management system API server.
 *
 * The version of the OpenAPI document: 1.0
 * Contact: support@swagger.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface InternalHandlersAdminCreditPreviewResponse {
    'count'?: number;
}
export interface InternalHandlersAdminCreditRequest {
    'amount': number;
    'description'?: string;
    'rule': InternalHandlersAdminCreditRequestRuleEnum;
    'ruleParams'?: { [key: string]: any; };
}

export const InternalHandlersAdminCreditRequestRuleEnum = {
    All: 'all',
    NewUsers: 'new_users',
    LowBalance: 'low_balance',
    Active: 'active'
} as const;

export type InternalHandlersAdminCreditRequestRuleEnum = typeof InternalHandlersAdminCreditRequestRuleEnum[keyof typeof InternalHandlersAdminCreditRequestRuleEnum];

export interface InternalHandlersAdminCreditResponse {
    'amount'?: number;
    'creditedCount'?: number;
    'newBalances'?: { [key: string]: number; };
    'success'?: boolean;
}
export interface InternalHandlersBalanceResponse {
    'data'?: ParierServerInternalServiceBalanceResponse;
    'success'?: boolean;
}
export interface InternalHandlersBetCommentResponse {
    'count'?: number;
    'data'?: Array<ParierServerInternalModelsBetCommentResponse>;
    'success'?: boolean;
    'total'?: number;
}
export interface InternalHandlersBetCreateResponse {
    'data'?: ParierServerInternalModelsBetResponse;
    'message'?: string;
    'success'?: boolean;
}
export interface InternalHandlersBetResponse {
    'count'?: number;
    'data'?: Array<ParierServerInternalModelsBetResponse>;
    'success'?: boolean;
    'total'?: number;
}
export interface InternalHandlersDepositRequest {
    'amount': number;
    'description'?: string;
}
export interface InternalHandlersDictionaryResponse {
    'data'?: Array<ParierServerInternalModelsDictionaryItemString>;
    'message'?: string;
    'success'?: boolean;
}
export interface InternalHandlersKeycloakLogoutRequest {
    'realm'?: string;
    'refresh_token'?: string;
}
export interface InternalHandlersLoginCodeRequest {
    'code': string;
    'iss': string;
    'redirect_uri': string;
}
export interface InternalHandlersMediaResponse {
    'content_type'?: string;
    'id'?: string;
    'name'?: string;
    'type_id'?: string;
    'type_name'?: string;
    'url'?: string;
}
export interface InternalHandlersProfileResponse {
    'created_at'?: string;
    'email'?: string;
    'expires_at'?: string;
    'id'?: string;
    'phone'?: string;
    'realm'?: string;
    'roles'?: Array<string>;
    'updated_at'?: string;
    'user_id'?: string;
    'username'?: string;
}
export interface InternalHandlersPropertiesEnumResponse {
    'description'?: string;
    'id'?: string;
    'name'?: string;
    'property'?: string;
    'property_type'?: ParierServerInternalModelsPropertyType;
    'value'?: object;
    'value_id'?: string;
}


export interface InternalHandlersPropertiesEnumsResponse {
    'data'?: Array<InternalHandlersPropertiesEnumResponse>;
    'total'?: number;
}
export interface InternalHandlersPropertiesTypeResponse {
    'description'?: string;
    'id'?: string;
    'name'?: string;
    'place'?: ParierServerInternalModelsPropertyPlace;
    'type'?: ParierServerInternalModelsPropertyType;
}


export interface InternalHandlersPropertiesTypesResponse {
    'data'?: Array<InternalHandlersPropertiesTypeResponse>;
    'total'?: number;
}
export interface InternalHandlersReferralCodeResponse {
    'code'?: string;
}
export interface InternalHandlersTransactionsResponse {
    'data'?: Array<ParierServerInternalServiceTransactionResponse>;
    'success'?: boolean;
    'total'?: number;
}
export interface InternalHandlersWithdrawRequest {
    'amount': number;
    'description'?: string;
}
export interface ParierServerInternalModelsAuthorResponse {
    'avatar'?: string;
    'background'?: string;
    'created_at'?: string;
    'deleted_at'?: string;
    'id'?: string;
    'likes'?: number;
    'rating'?: number;
    'updated_at'?: string;
    'username'?: string;
    'verified'?: boolean;
    'win_rate'?: number;
}
export interface ParierServerInternalModelsBetCommentCreateRequest {
    'content'?: string;
    'language'?: string;
    'parent_id'?: string;
    'user'?: ParierServerInternalModelsUser;
}
export interface ParierServerInternalModelsBetCommentRequest {
    'language'?: string;
    'limit'?: number;
    'offset'?: number;
    'search'?: string;
    'sort_by'?: string;
    'sort_dir'?: string;
    'user'?: ParierServerInternalModelsUser;
}
export interface ParierServerInternalModelsBetCommentResponse {
    'author'?: ParierServerInternalModelsAuthorResponse;
    'content'?: string;
    'created_at'?: string;
    'deleted_at'?: string;
    'id'?: string;
    'is_liked_by_me'?: boolean;
    'likes'?: number;
    'parent'?: ParierServerInternalModelsBetCommentResponse;
    'updated_at'?: string;
}
export interface ParierServerInternalModelsBetCreateRequest {
    'amount'?: string;
    'category_id'?: string;
    'coefficient'?: string;
    'deadline'?: string;
    'description'?: string;
    'language'?: string;
    'status_id'?: string;
    'title'?: string;
    'type_id'?: string;
    'user'?: ParierServerInternalModelsUser;
    'verification_source_id'?: Array<string>;
}
export interface ParierServerInternalModelsBetRequest {
    'category_id'?: string;
    'coefficient'?: string;
    'deadline'?: string;
    'description'?: string;
    'id'?: string;
    'language'?: string;
    'limit'?: number;
    'max_amount'?: string;
    'min_amount'?: string;
    'offset'?: number;
    'sort_by'?: string;
    'sort_dir'?: string;
    'status_id'?: string;
    'title'?: string;
    'type_id'?: string;
    'user'?: ParierServerInternalModelsUser;
    'verification_source_id'?: Array<string>;
}
export interface ParierServerInternalModelsBetResponse {
    'amount'?: number;
    'author'?: ParierServerInternalModelsAuthorResponse;
    'bets_count'?: number;
    'category_id'?: string;
    'category_name'?: string;
    'coefficient'?: number;
    'comments'?: number;
    'created_at'?: string;
    'deadline'?: string;
    'deleted_at'?: string;
    'description'?: string;
    'id'?: string;
    'is_liked_by_me'?: boolean;
    'is_rated_by_me'?: boolean;
    'likes'?: number;
    'rating'?: number;
    'status_id'?: string;
    'status_name'?: string;
    'title'?: string;
    'type_id'?: string;
    'type_name'?: string;
    'updated_at'?: string;
    'verification_sources'?: Array<ParierServerInternalModelsVerificationSourceResponse>;
}
export interface ParierServerInternalModelsDefaultRequest {
    'language'?: string;
    'user'?: ParierServerInternalModelsUser;
}
export interface ParierServerInternalModelsDictionaryItemString {
    'description'?: string;
    'id'?: string;
    'name'?: string;
}
export interface ParierServerInternalModelsDictionaryRequest {
    'language'?: string;
    'search'?: string;
    'user'?: ParierServerInternalModelsUser;
}
export interface ParierServerInternalModelsErrorResponse {
    'details'?: string;
    'error'?: string;
    'success'?: boolean;
}

export const ParierServerInternalModelsPropertyPlace = {
    PropertyPlaceBet: 'BET',
    PropertyPlaceSource: 'SOURCE',
    PropertyPlaceUser: 'USER'
} as const;

export type ParierServerInternalModelsPropertyPlace = typeof ParierServerInternalModelsPropertyPlace[keyof typeof ParierServerInternalModelsPropertyPlace];



export const ParierServerInternalModelsPropertyType = {
    PropertyTypeDate: 'DATE',
    PropertyTypeDecimal: 'DECIMAL',
    PropertyTypeInteger: 'INTEGER',
    PropertyTypeLocalization: 'LOCALIZATION',
    PropertyTypeBoolean: 'BOOLEAN',
    PropertyTypeText: 'TEXT',
    PropertyTypeJSONObject: 'JSONOBJECT',
    PropertyTypeJSONArray: 'JSONARRAY',
    PropertyTypeMedia: 'MEDIA',
    PropertyTypeEnum: 'ENUM'
} as const;

export type ParierServerInternalModelsPropertyType = typeof ParierServerInternalModelsPropertyType[keyof typeof ParierServerInternalModelsPropertyType];


export interface ParierServerInternalModelsSuccessResponse {
    'data'?: object;
    'message'?: string;
    'success'?: boolean;
}
export interface ParierServerInternalModelsUser {
    'data'?: { [key: string]: any; };
    'email'?: string;
    'external_id'?: string;
    'id'?: string;
    'phone'?: string;
    'realm'?: string;
    'roles'?: Array<string>;
    'session_id'?: string;
    'username'?: string;
}
export interface ParierServerInternalModelsVerificationSourceResponse {
    'id'?: string;
    'name'?: string;
}
export interface ParierServerInternalRepositoryPropertiesEnumFilter {
    'language'?: string;
    'limit'?: number;
    'offset'?: number;
    'property_type'?: string;
    'search'?: string;
    'sort_by'?: string;
    'sort_dir'?: string;
    'user'?: ParierServerInternalModelsUser;
}
export interface ParierServerInternalRepositoryPropertiesTypeFilter {
    'group'?: string;
    'language'?: string;
    'limit'?: number;
    'offset'?: number;
    'place'?: ParierServerInternalModelsPropertyPlace;
    'search'?: string;
    'sort_by'?: string;
    'sort_dir'?: string;
    'user'?: ParierServerInternalModelsUser;
}


export interface ParierServerInternalServiceBalanceResponse {
    'balance'?: number;
    'totalDeposited'?: number;
    'totalSpent'?: number;
    'totalWithdrawn'?: number;
    'totalWon'?: number;
    'userId'?: string;
}
export interface ParierServerInternalServiceReferralItemResponse {
    'created_at'?: string;
    'earnings'?: number;
    'id'?: string;
    'referred_id'?: string;
    'referred_name'?: string;
}
export interface ParierServerInternalServiceReferralStatsResponse {
    'referrals'?: Array<ParierServerInternalServiceReferralItemResponse>;
    'total_earnings'?: number;
    'total_referrals'?: number;
}
export interface ParierServerInternalServiceTransactionResponse {
    'amount'?: number;
    'createdAt'?: string;
    'description'?: string;
    'id'?: string;
    'relatedBetId'?: string;
    'relatedUserId'?: string;
    'type'?: string;
    'userId'?: string;
}

/**
 * AdminApi - axios parameter creator
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get count of users matching the rule
         * @summary Get admin credit preview
         * @param {string} rule Rule
         * @param {string} [days] Days
         * @param {string} [maxBalance] Max balance
         * @param {string} [minBets] Min bets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreditPreviewGet: async (rule: string, days?: string, maxBalance?: string, minBets?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('adminCreditPreviewGet', 'rule', rule)
            const localVarPath = `/admin/credit-preview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (rule !== undefined) {
                localVarQueryParameter['rule'] = rule;
            }

            if (days !== undefined) {
                localVarQueryParameter['days'] = days;
            }

            if (maxBalance !== undefined) {
                localVarQueryParameter['maxBalance'] = maxBalance;
            }

            if (minBets !== undefined) {
                localVarQueryParameter['minBets'] = minBets;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Credit tokens to users by rule
         * @summary Credit tokens to users by rule
         * @param {InternalHandlersAdminCreditRequest} request Admin credit request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreditTokensPost: async (request: InternalHandlersAdminCreditRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('adminCreditTokensPost', 'request', request)
            const localVarPath = `/admin/credit-tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * Get count of users matching the rule
         * @summary Get admin credit preview
         * @param {string} rule Rule
         * @param {string} [days] Days
         * @param {string} [maxBalance] Max balance
         * @param {string} [minBets] Min bets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminCreditPreviewGet(rule: string, days?: string, maxBalance?: string, minBets?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHandlersAdminCreditPreviewResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminCreditPreviewGet(rule, days, maxBalance, minBets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminCreditPreviewGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Credit tokens to users by rule
         * @summary Credit tokens to users by rule
         * @param {InternalHandlersAdminCreditRequest} request Admin credit request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminCreditTokensPost(request: InternalHandlersAdminCreditRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHandlersAdminCreditResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminCreditTokensPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminCreditTokensPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminApi - factory interface
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * Get count of users matching the rule
         * @summary Get admin credit preview
         * @param {string} rule Rule
         * @param {string} [days] Days
         * @param {string} [maxBalance] Max balance
         * @param {string} [minBets] Min bets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreditPreviewGet(rule: string, days?: string, maxBalance?: string, minBets?: string, options?: RawAxiosRequestConfig): AxiosPromise<InternalHandlersAdminCreditPreviewResponse> {
            return localVarFp.adminCreditPreviewGet(rule, days, maxBalance, minBets, options).then((request) => request(axios, basePath));
        },
        /**
         * Credit tokens to users by rule
         * @summary Credit tokens to users by rule
         * @param {InternalHandlersAdminCreditRequest} request Admin credit request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreditTokensPost(request: InternalHandlersAdminCreditRequest, options?: RawAxiosRequestConfig): AxiosPromise<InternalHandlersAdminCreditResponse> {
            return localVarFp.adminCreditTokensPost(request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 */
export class AdminApi extends BaseAPI {
    /**
     * Get count of users matching the rule
     * @summary Get admin credit preview
     * @param {string} rule Rule
     * @param {string} [days] Days
     * @param {string} [maxBalance] Max balance
     * @param {string} [minBets] Min bets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminCreditPreviewGet(rule: string, days?: string, maxBalance?: string, minBets?: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminCreditPreviewGet(rule, days, maxBalance, minBets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Credit tokens to users by rule
     * @summary Credit tokens to users by rule
     * @param {InternalHandlersAdminCreditRequest} request Admin credit request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminCreditTokensPost(request: InternalHandlersAdminCreditRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminCreditTokensPost(request, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authenticate user through Keycloak and return tokens
         * @summary Login via Keycloak
         * @param {InternalHandlersLoginCodeRequest} credentials Login credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginCodePut: async (credentials: InternalHandlersLoginCodeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'credentials' is not null or undefined
            assertParamExists('authLoginCodePut', 'credentials', credentials)
            const localVarPath = `/auth/login-code`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(credentials, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Logout user from Keycloak
         * @summary Logout user
         * @param {InternalHandlersKeycloakLogoutRequest} request Logout parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogoutPut: async (request: InternalHandlersKeycloakLogoutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('authLogoutPut', 'request', request)
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current user profile information from Keycloak
         * @summary Get current user profile
         * @param {ParierServerInternalModelsDefaultRequest} request Profile parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authProfilePost: async (request: ParierServerInternalModelsDefaultRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('authProfilePost', 'request', request)
            const localVarPath = `/auth/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Authenticate user through Keycloak and return tokens
         * @summary Login via Keycloak
         * @param {InternalHandlersLoginCodeRequest} credentials Login credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLoginCodePut(credentials: InternalHandlersLoginCodeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHandlersProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLoginCodePut(credentials, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authLoginCodePut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Logout user from Keycloak
         * @summary Logout user
         * @param {InternalHandlersKeycloakLogoutRequest} request Logout parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLogoutPut(request: InternalHandlersKeycloakLogoutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParierServerInternalModelsSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLogoutPut(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authLogoutPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current user profile information from Keycloak
         * @summary Get current user profile
         * @param {ParierServerInternalModelsDefaultRequest} request Profile parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authProfilePost(request: ParierServerInternalModelsDefaultRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHandlersProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authProfilePost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authProfilePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Authenticate user through Keycloak and return tokens
         * @summary Login via Keycloak
         * @param {InternalHandlersLoginCodeRequest} credentials Login credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginCodePut(credentials: InternalHandlersLoginCodeRequest, options?: RawAxiosRequestConfig): AxiosPromise<InternalHandlersProfileResponse> {
            return localVarFp.authLoginCodePut(credentials, options).then((request) => request(axios, basePath));
        },
        /**
         * Logout user from Keycloak
         * @summary Logout user
         * @param {InternalHandlersKeycloakLogoutRequest} request Logout parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogoutPut(request: InternalHandlersKeycloakLogoutRequest, options?: RawAxiosRequestConfig): AxiosPromise<ParierServerInternalModelsSuccessResponse> {
            return localVarFp.authLogoutPut(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current user profile information from Keycloak
         * @summary Get current user profile
         * @param {ParierServerInternalModelsDefaultRequest} request Profile parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authProfilePost(request: ParierServerInternalModelsDefaultRequest, options?: RawAxiosRequestConfig): AxiosPromise<InternalHandlersProfileResponse> {
            return localVarFp.authProfilePost(request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 */
export class AuthApi extends BaseAPI {
    /**
     * Authenticate user through Keycloak and return tokens
     * @summary Login via Keycloak
     * @param {InternalHandlersLoginCodeRequest} credentials Login credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authLoginCodePut(credentials: InternalHandlersLoginCodeRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authLoginCodePut(credentials, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Logout user from Keycloak
     * @summary Logout user
     * @param {InternalHandlersKeycloakLogoutRequest} request Logout parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authLogoutPut(request: InternalHandlersKeycloakLogoutRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authLogoutPut(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current user profile information from Keycloak
     * @summary Get current user profile
     * @param {ParierServerInternalModelsDefaultRequest} request Profile parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authProfilePost(request: ParierServerInternalModelsDefaultRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authProfilePost(request, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CoreApi - axios parameter creator
 */
export const CoreApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get locales
         * @summary Get locales
         * @param {string} lang Language
         * @param {string} ns Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreLocalesLangNsGet: async (lang: string, ns: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lang' is not null or undefined
            assertParamExists('coreLocalesLangNsGet', 'lang', lang)
            // verify required parameter 'ns' is not null or undefined
            assertParamExists('coreLocalesLangNsGet', 'ns', ns)
            const localVarPath = `/core/locales/{lang}/{ns}`
                .replace(`{${"lang"}}`, encodeURIComponent(String(lang)))
                .replace(`{${"ns"}}`, encodeURIComponent(String(ns)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get properties enums
         * @summary Get properties enums
         * @param {ParierServerInternalRepositoryPropertiesEnumFilter} filter Filter parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        corePropertiesEnumsPost: async (filter: ParierServerInternalRepositoryPropertiesEnumFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('corePropertiesEnumsPost', 'filter', filter)
            const localVarPath = `/core/properties-enums`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get properties type by id
         * @summary Get properties type by id
         * @param {string} id Properties type id
         * @param {ParierServerInternalModelsDefaultRequest} filter Filter parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        corePropertiesTypesIdPost: async (id: string, filter: ParierServerInternalModelsDefaultRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('corePropertiesTypesIdPost', 'id', id)
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('corePropertiesTypesIdPost', 'filter', filter)
            const localVarPath = `/core/properties-types/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get paginated list of properties types with filtering
         * @summary Get paginated list of properties types
         * @param {ParierServerInternalRepositoryPropertiesTypeFilter} filter Filter parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        corePropertiesTypesPost: async (filter: ParierServerInternalRepositoryPropertiesTypeFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('corePropertiesTypesPost', 'filter', filter)
            const localVarPath = `/core/properties-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoreApi - functional programming interface
 */
export const CoreApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CoreApiAxiosParamCreator(configuration)
    return {
        /**
         * Get locales
         * @summary Get locales
         * @param {string} lang Language
         * @param {string} ns Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coreLocalesLangNsGet(lang: string, ns: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coreLocalesLangNsGet(lang, ns, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreApi.coreLocalesLangNsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get properties enums
         * @summary Get properties enums
         * @param {ParierServerInternalRepositoryPropertiesEnumFilter} filter Filter parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async corePropertiesEnumsPost(filter: ParierServerInternalRepositoryPropertiesEnumFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHandlersPropertiesEnumsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.corePropertiesEnumsPost(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreApi.corePropertiesEnumsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get properties type by id
         * @summary Get properties type by id
         * @param {string} id Properties type id
         * @param {ParierServerInternalModelsDefaultRequest} filter Filter parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async corePropertiesTypesIdPost(id: string, filter: ParierServerInternalModelsDefaultRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHandlersPropertiesTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.corePropertiesTypesIdPost(id, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreApi.corePropertiesTypesIdPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get paginated list of properties types with filtering
         * @summary Get paginated list of properties types
         * @param {ParierServerInternalRepositoryPropertiesTypeFilter} filter Filter parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async corePropertiesTypesPost(filter: ParierServerInternalRepositoryPropertiesTypeFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHandlersPropertiesTypesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.corePropertiesTypesPost(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreApi.corePropertiesTypesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CoreApi - factory interface
 */
export const CoreApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CoreApiFp(configuration)
    return {
        /**
         * Get locales
         * @summary Get locales
         * @param {string} lang Language
         * @param {string} ns Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreLocalesLangNsGet(lang: string, ns: string, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.coreLocalesLangNsGet(lang, ns, options).then((request) => request(axios, basePath));
        },
        /**
         * Get properties enums
         * @summary Get properties enums
         * @param {ParierServerInternalRepositoryPropertiesEnumFilter} filter Filter parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        corePropertiesEnumsPost(filter: ParierServerInternalRepositoryPropertiesEnumFilter, options?: RawAxiosRequestConfig): AxiosPromise<InternalHandlersPropertiesEnumsResponse> {
            return localVarFp.corePropertiesEnumsPost(filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Get properties type by id
         * @summary Get properties type by id
         * @param {string} id Properties type id
         * @param {ParierServerInternalModelsDefaultRequest} filter Filter parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        corePropertiesTypesIdPost(id: string, filter: ParierServerInternalModelsDefaultRequest, options?: RawAxiosRequestConfig): AxiosPromise<InternalHandlersPropertiesTypeResponse> {
            return localVarFp.corePropertiesTypesIdPost(id, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Get paginated list of properties types with filtering
         * @summary Get paginated list of properties types
         * @param {ParierServerInternalRepositoryPropertiesTypeFilter} filter Filter parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        corePropertiesTypesPost(filter: ParierServerInternalRepositoryPropertiesTypeFilter, options?: RawAxiosRequestConfig): AxiosPromise<InternalHandlersPropertiesTypesResponse> {
            return localVarFp.corePropertiesTypesPost(filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CoreApi - object-oriented interface
 */
export class CoreApi extends BaseAPI {
    /**
     * Get locales
     * @summary Get locales
     * @param {string} lang Language
     * @param {string} ns Namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coreLocalesLangNsGet(lang: string, ns: string, options?: RawAxiosRequestConfig) {
        return CoreApiFp(this.configuration).coreLocalesLangNsGet(lang, ns, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get properties enums
     * @summary Get properties enums
     * @param {ParierServerInternalRepositoryPropertiesEnumFilter} filter Filter parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public corePropertiesEnumsPost(filter: ParierServerInternalRepositoryPropertiesEnumFilter, options?: RawAxiosRequestConfig) {
        return CoreApiFp(this.configuration).corePropertiesEnumsPost(filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get properties type by id
     * @summary Get properties type by id
     * @param {string} id Properties type id
     * @param {ParierServerInternalModelsDefaultRequest} filter Filter parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public corePropertiesTypesIdPost(id: string, filter: ParierServerInternalModelsDefaultRequest, options?: RawAxiosRequestConfig) {
        return CoreApiFp(this.configuration).corePropertiesTypesIdPost(id, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get paginated list of properties types with filtering
     * @summary Get paginated list of properties types
     * @param {ParierServerInternalRepositoryPropertiesTypeFilter} filter Filter parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public corePropertiesTypesPost(filter: ParierServerInternalRepositoryPropertiesTypeFilter, options?: RawAxiosRequestConfig) {
        return CoreApiFp(this.configuration).corePropertiesTypesPost(filter, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MediaApi - axios parameter creator
 */
export const MediaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Download a file from S3 storage
         * @summary Download file
         * @param {string} id Media ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaIdDownloadGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('mediaIdDownloadGet', 'id', id)
            const localVarPath = `/media/{id}/download`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get media file information
         * @summary Get media info
         * @param {string} id Media ID
         * @param {ParierServerInternalModelsDefaultRequest} request Get media parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaIdPost: async (id: string, request: ParierServerInternalModelsDefaultRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('mediaIdPost', 'id', id)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('mediaIdPost', 'request', request)
            const localVarPath = `/media/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Raw a file from S3 storage
         * @summary Raw file
         * @param {string} id Media ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaIdRawGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('mediaIdRawGet', 'id', id)
            const localVarPath = `/media/{id}/raw`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MediaApi - functional programming interface
 */
export const MediaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MediaApiAxiosParamCreator(configuration)
    return {
        /**
         * Download a file from S3 storage
         * @summary Download file
         * @param {string} id Media ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mediaIdDownloadGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mediaIdDownloadGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.mediaIdDownloadGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get media file information
         * @summary Get media info
         * @param {string} id Media ID
         * @param {ParierServerInternalModelsDefaultRequest} request Get media parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mediaIdPost(id: string, request: ParierServerInternalModelsDefaultRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHandlersMediaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mediaIdPost(id, request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.mediaIdPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Raw a file from S3 storage
         * @summary Raw file
         * @param {string} id Media ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mediaIdRawGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mediaIdRawGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.mediaIdRawGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MediaApi - factory interface
 */
export const MediaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MediaApiFp(configuration)
    return {
        /**
         * Download a file from S3 storage
         * @summary Download file
         * @param {string} id Media ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaIdDownloadGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.mediaIdDownloadGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get media file information
         * @summary Get media info
         * @param {string} id Media ID
         * @param {ParierServerInternalModelsDefaultRequest} request Get media parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaIdPost(id: string, request: ParierServerInternalModelsDefaultRequest, options?: RawAxiosRequestConfig): AxiosPromise<InternalHandlersMediaResponse> {
            return localVarFp.mediaIdPost(id, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Raw a file from S3 storage
         * @summary Raw file
         * @param {string} id Media ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaIdRawGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.mediaIdRawGet(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MediaApi - object-oriented interface
 */
export class MediaApi extends BaseAPI {
    /**
     * Download a file from S3 storage
     * @summary Download file
     * @param {string} id Media ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mediaIdDownloadGet(id: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).mediaIdDownloadGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get media file information
     * @summary Get media info
     * @param {string} id Media ID
     * @param {ParierServerInternalModelsDefaultRequest} request Get media parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mediaIdPost(id: string, request: ParierServerInternalModelsDefaultRequest, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).mediaIdPost(id, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Raw a file from S3 storage
     * @summary Raw file
     * @param {string} id Media ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mediaIdRawGet(id: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).mediaIdRawGet(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ParierApi - axios parameter creator
 */
export const ParierApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create bet comment
         * @summary Create bet comment
         * @param {string} betId Bet ID
         * @param {ParierServerInternalModelsBetCommentCreateRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parierBetBetIdCommentPut: async (betId: string, request: ParierServerInternalModelsBetCommentCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'betId' is not null or undefined
            assertParamExists('parierBetBetIdCommentPut', 'betId', betId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('parierBetBetIdCommentPut', 'request', request)
            const localVarPath = `/parier/bet/{bet_id}/comment`
                .replace(`{${"bet_id"}}`, encodeURIComponent(String(betId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get bet comments
         * @summary Get bet comments
         * @param {string} betId Bet ID
         * @param {ParierServerInternalModelsBetCommentRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parierBetBetIdCommentsPost: async (betId: string, request: ParierServerInternalModelsBetCommentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'betId' is not null or undefined
            assertParamExists('parierBetBetIdCommentsPost', 'betId', betId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('parierBetBetIdCommentsPost', 'request', request)
            const localVarPath = `/parier/bet/{bet_id}/comments`
                .replace(`{${"bet_id"}}`, encodeURIComponent(String(betId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Like bet
         * @summary Like bet
         * @param {string} betId Bet ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parierBetBetIdLikePost: async (betId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'betId' is not null or undefined
            assertParamExists('parierBetBetIdLikePost', 'betId', betId)
            const localVarPath = `/parier/bet/{bet_id}/like`
                .replace(`{${"bet_id"}}`, encodeURIComponent(String(betId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unlike bet
         * @summary Unlike bet
         * @param {string} betId Bet ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parierBetBetIdUnlikePost: async (betId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'betId' is not null or undefined
            assertParamExists('parierBetBetIdUnlikePost', 'betId', betId)
            const localVarPath = `/parier/bet/{bet_id}/unlike`
                .replace(`{${"bet_id"}}`, encodeURIComponent(String(betId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get bets
         * @summary Get bets
         * @param {ParierServerInternalModelsBetRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parierBetPost: async (request: ParierServerInternalModelsBetRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('parierBetPost', 'request', request)
            const localVarPath = `/parier/bet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create bet
         * @summary Create bet
         * @param {ParierServerInternalModelsBetCreateRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parierBetPut: async (request: ParierServerInternalModelsBetCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('parierBetPut', 'request', request)
            const localVarPath = `/parier/bet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get bet statuses
         * @summary Get bet statuses
         * @param {ParierServerInternalModelsDictionaryRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parierBetStatusesPost: async (request: ParierServerInternalModelsDictionaryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('parierBetStatusesPost', 'request', request)
            const localVarPath = `/parier/bet-statuses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get bet types
         * @summary Get bet types
         * @param {ParierServerInternalModelsDictionaryRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parierBetTypesPost: async (request: ParierServerInternalModelsDictionaryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('parierBetTypesPost', 'request', request)
            const localVarPath = `/parier/bet-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get categories
         * @summary Get categories
         * @param {ParierServerInternalModelsDictionaryRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parierCategoriesPost: async (request: ParierServerInternalModelsDictionaryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('parierCategoriesPost', 'request', request)
            const localVarPath = `/parier/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Like bet comment
         * @summary Like bet comment
         * @param {string} commentId Comment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parierCommentCommentIdLikePost: async (commentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('parierCommentCommentIdLikePost', 'commentId', commentId)
            const localVarPath = `/parier/comment/{comment_id}/like`
                .replace(`{${"comment_id"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unlike bet comment
         * @summary Unlike bet comment
         * @param {string} commentId Comment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parierCommentCommentIdUnlikePost: async (commentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('parierCommentCommentIdUnlikePost', 'commentId', commentId)
            const localVarPath = `/parier/comment/{comment_id}/unlike`
                .replace(`{${"comment_id"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get like types
         * @summary Get like types
         * @param {ParierServerInternalModelsDictionaryRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parierLikeTypesPost: async (request: ParierServerInternalModelsDictionaryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('parierLikeTypesPost', 'request', request)
            const localVarPath = `/parier/like-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get verification sources
         * @summary Get verification sources
         * @param {ParierServerInternalModelsDictionaryRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parierVerificationSourcesPost: async (request: ParierServerInternalModelsDictionaryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('parierVerificationSourcesPost', 'request', request)
            const localVarPath = `/parier/verification-sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ParierApi - functional programming interface
 */
export const ParierApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ParierApiAxiosParamCreator(configuration)
    return {
        /**
         * Create bet comment
         * @summary Create bet comment
         * @param {string} betId Bet ID
         * @param {ParierServerInternalModelsBetCommentCreateRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parierBetBetIdCommentPut(betId: string, request: ParierServerInternalModelsBetCommentCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParierServerInternalModelsSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.parierBetBetIdCommentPut(betId, request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParierApi.parierBetBetIdCommentPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get bet comments
         * @summary Get bet comments
         * @param {string} betId Bet ID
         * @param {ParierServerInternalModelsBetCommentRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parierBetBetIdCommentsPost(betId: string, request: ParierServerInternalModelsBetCommentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHandlersBetCommentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.parierBetBetIdCommentsPost(betId, request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParierApi.parierBetBetIdCommentsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Like bet
         * @summary Like bet
         * @param {string} betId Bet ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parierBetBetIdLikePost(betId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParierServerInternalModelsSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.parierBetBetIdLikePost(betId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParierApi.parierBetBetIdLikePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unlike bet
         * @summary Unlike bet
         * @param {string} betId Bet ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parierBetBetIdUnlikePost(betId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParierServerInternalModelsSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.parierBetBetIdUnlikePost(betId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParierApi.parierBetBetIdUnlikePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get bets
         * @summary Get bets
         * @param {ParierServerInternalModelsBetRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parierBetPost(request: ParierServerInternalModelsBetRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHandlersBetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.parierBetPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParierApi.parierBetPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create bet
         * @summary Create bet
         * @param {ParierServerInternalModelsBetCreateRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parierBetPut(request: ParierServerInternalModelsBetCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHandlersBetCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.parierBetPut(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParierApi.parierBetPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get bet statuses
         * @summary Get bet statuses
         * @param {ParierServerInternalModelsDictionaryRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parierBetStatusesPost(request: ParierServerInternalModelsDictionaryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHandlersDictionaryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.parierBetStatusesPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParierApi.parierBetStatusesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get bet types
         * @summary Get bet types
         * @param {ParierServerInternalModelsDictionaryRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parierBetTypesPost(request: ParierServerInternalModelsDictionaryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHandlersDictionaryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.parierBetTypesPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParierApi.parierBetTypesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get categories
         * @summary Get categories
         * @param {ParierServerInternalModelsDictionaryRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parierCategoriesPost(request: ParierServerInternalModelsDictionaryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHandlersDictionaryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.parierCategoriesPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParierApi.parierCategoriesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Like bet comment
         * @summary Like bet comment
         * @param {string} commentId Comment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parierCommentCommentIdLikePost(commentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParierServerInternalModelsSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.parierCommentCommentIdLikePost(commentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParierApi.parierCommentCommentIdLikePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unlike bet comment
         * @summary Unlike bet comment
         * @param {string} commentId Comment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parierCommentCommentIdUnlikePost(commentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParierServerInternalModelsSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.parierCommentCommentIdUnlikePost(commentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParierApi.parierCommentCommentIdUnlikePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get like types
         * @summary Get like types
         * @param {ParierServerInternalModelsDictionaryRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parierLikeTypesPost(request: ParierServerInternalModelsDictionaryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHandlersDictionaryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.parierLikeTypesPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParierApi.parierLikeTypesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get verification sources
         * @summary Get verification sources
         * @param {ParierServerInternalModelsDictionaryRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parierVerificationSourcesPost(request: ParierServerInternalModelsDictionaryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHandlersDictionaryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.parierVerificationSourcesPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParierApi.parierVerificationSourcesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ParierApi - factory interface
 */
export const ParierApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ParierApiFp(configuration)
    return {
        /**
         * Create bet comment
         * @summary Create bet comment
         * @param {string} betId Bet ID
         * @param {ParierServerInternalModelsBetCommentCreateRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parierBetBetIdCommentPut(betId: string, request: ParierServerInternalModelsBetCommentCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ParierServerInternalModelsSuccessResponse> {
            return localVarFp.parierBetBetIdCommentPut(betId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Get bet comments
         * @summary Get bet comments
         * @param {string} betId Bet ID
         * @param {ParierServerInternalModelsBetCommentRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parierBetBetIdCommentsPost(betId: string, request: ParierServerInternalModelsBetCommentRequest, options?: RawAxiosRequestConfig): AxiosPromise<InternalHandlersBetCommentResponse> {
            return localVarFp.parierBetBetIdCommentsPost(betId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Like bet
         * @summary Like bet
         * @param {string} betId Bet ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parierBetBetIdLikePost(betId: string, options?: RawAxiosRequestConfig): AxiosPromise<ParierServerInternalModelsSuccessResponse> {
            return localVarFp.parierBetBetIdLikePost(betId, options).then((request) => request(axios, basePath));
        },
        /**
         * Unlike bet
         * @summary Unlike bet
         * @param {string} betId Bet ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parierBetBetIdUnlikePost(betId: string, options?: RawAxiosRequestConfig): AxiosPromise<ParierServerInternalModelsSuccessResponse> {
            return localVarFp.parierBetBetIdUnlikePost(betId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get bets
         * @summary Get bets
         * @param {ParierServerInternalModelsBetRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parierBetPost(request: ParierServerInternalModelsBetRequest, options?: RawAxiosRequestConfig): AxiosPromise<InternalHandlersBetResponse> {
            return localVarFp.parierBetPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Create bet
         * @summary Create bet
         * @param {ParierServerInternalModelsBetCreateRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parierBetPut(request: ParierServerInternalModelsBetCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<InternalHandlersBetCreateResponse> {
            return localVarFp.parierBetPut(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Get bet statuses
         * @summary Get bet statuses
         * @param {ParierServerInternalModelsDictionaryRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parierBetStatusesPost(request: ParierServerInternalModelsDictionaryRequest, options?: RawAxiosRequestConfig): AxiosPromise<InternalHandlersDictionaryResponse> {
            return localVarFp.parierBetStatusesPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Get bet types
         * @summary Get bet types
         * @param {ParierServerInternalModelsDictionaryRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parierBetTypesPost(request: ParierServerInternalModelsDictionaryRequest, options?: RawAxiosRequestConfig): AxiosPromise<InternalHandlersDictionaryResponse> {
            return localVarFp.parierBetTypesPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Get categories
         * @summary Get categories
         * @param {ParierServerInternalModelsDictionaryRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parierCategoriesPost(request: ParierServerInternalModelsDictionaryRequest, options?: RawAxiosRequestConfig): AxiosPromise<InternalHandlersDictionaryResponse> {
            return localVarFp.parierCategoriesPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Like bet comment
         * @summary Like bet comment
         * @param {string} commentId Comment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parierCommentCommentIdLikePost(commentId: string, options?: RawAxiosRequestConfig): AxiosPromise<ParierServerInternalModelsSuccessResponse> {
            return localVarFp.parierCommentCommentIdLikePost(commentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Unlike bet comment
         * @summary Unlike bet comment
         * @param {string} commentId Comment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parierCommentCommentIdUnlikePost(commentId: string, options?: RawAxiosRequestConfig): AxiosPromise<ParierServerInternalModelsSuccessResponse> {
            return localVarFp.parierCommentCommentIdUnlikePost(commentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get like types
         * @summary Get like types
         * @param {ParierServerInternalModelsDictionaryRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parierLikeTypesPost(request: ParierServerInternalModelsDictionaryRequest, options?: RawAxiosRequestConfig): AxiosPromise<InternalHandlersDictionaryResponse> {
            return localVarFp.parierLikeTypesPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Get verification sources
         * @summary Get verification sources
         * @param {ParierServerInternalModelsDictionaryRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parierVerificationSourcesPost(request: ParierServerInternalModelsDictionaryRequest, options?: RawAxiosRequestConfig): AxiosPromise<InternalHandlersDictionaryResponse> {
            return localVarFp.parierVerificationSourcesPost(request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ParierApi - object-oriented interface
 */
export class ParierApi extends BaseAPI {
    /**
     * Create bet comment
     * @summary Create bet comment
     * @param {string} betId Bet ID
     * @param {ParierServerInternalModelsBetCommentCreateRequest} request Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public parierBetBetIdCommentPut(betId: string, request: ParierServerInternalModelsBetCommentCreateRequest, options?: RawAxiosRequestConfig) {
        return ParierApiFp(this.configuration).parierBetBetIdCommentPut(betId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get bet comments
     * @summary Get bet comments
     * @param {string} betId Bet ID
     * @param {ParierServerInternalModelsBetCommentRequest} request Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public parierBetBetIdCommentsPost(betId: string, request: ParierServerInternalModelsBetCommentRequest, options?: RawAxiosRequestConfig) {
        return ParierApiFp(this.configuration).parierBetBetIdCommentsPost(betId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Like bet
     * @summary Like bet
     * @param {string} betId Bet ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public parierBetBetIdLikePost(betId: string, options?: RawAxiosRequestConfig) {
        return ParierApiFp(this.configuration).parierBetBetIdLikePost(betId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unlike bet
     * @summary Unlike bet
     * @param {string} betId Bet ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public parierBetBetIdUnlikePost(betId: string, options?: RawAxiosRequestConfig) {
        return ParierApiFp(this.configuration).parierBetBetIdUnlikePost(betId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get bets
     * @summary Get bets
     * @param {ParierServerInternalModelsBetRequest} request Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public parierBetPost(request: ParierServerInternalModelsBetRequest, options?: RawAxiosRequestConfig) {
        return ParierApiFp(this.configuration).parierBetPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create bet
     * @summary Create bet
     * @param {ParierServerInternalModelsBetCreateRequest} request Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public parierBetPut(request: ParierServerInternalModelsBetCreateRequest, options?: RawAxiosRequestConfig) {
        return ParierApiFp(this.configuration).parierBetPut(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get bet statuses
     * @summary Get bet statuses
     * @param {ParierServerInternalModelsDictionaryRequest} request Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public parierBetStatusesPost(request: ParierServerInternalModelsDictionaryRequest, options?: RawAxiosRequestConfig) {
        return ParierApiFp(this.configuration).parierBetStatusesPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get bet types
     * @summary Get bet types
     * @param {ParierServerInternalModelsDictionaryRequest} request Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public parierBetTypesPost(request: ParierServerInternalModelsDictionaryRequest, options?: RawAxiosRequestConfig) {
        return ParierApiFp(this.configuration).parierBetTypesPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get categories
     * @summary Get categories
     * @param {ParierServerInternalModelsDictionaryRequest} request Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public parierCategoriesPost(request: ParierServerInternalModelsDictionaryRequest, options?: RawAxiosRequestConfig) {
        return ParierApiFp(this.configuration).parierCategoriesPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Like bet comment
     * @summary Like bet comment
     * @param {string} commentId Comment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public parierCommentCommentIdLikePost(commentId: string, options?: RawAxiosRequestConfig) {
        return ParierApiFp(this.configuration).parierCommentCommentIdLikePost(commentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unlike bet comment
     * @summary Unlike bet comment
     * @param {string} commentId Comment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public parierCommentCommentIdUnlikePost(commentId: string, options?: RawAxiosRequestConfig) {
        return ParierApiFp(this.configuration).parierCommentCommentIdUnlikePost(commentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get like types
     * @summary Get like types
     * @param {ParierServerInternalModelsDictionaryRequest} request Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public parierLikeTypesPost(request: ParierServerInternalModelsDictionaryRequest, options?: RawAxiosRequestConfig) {
        return ParierApiFp(this.configuration).parierLikeTypesPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get verification sources
     * @summary Get verification sources
     * @param {ParierServerInternalModelsDictionaryRequest} request Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public parierVerificationSourcesPost(request: ParierServerInternalModelsDictionaryRequest, options?: RawAxiosRequestConfig) {
        return ParierApiFp(this.configuration).parierVerificationSourcesPost(request, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReferralApi - axios parameter creator
 */
export const ReferralApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get or generate user\'s referral code
         * @summary Get referral code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referralCodeGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/referral/code`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get referral statistics (total referrals, earnings, list)
         * @summary Get referral stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referralStatsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/referral/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReferralApi - functional programming interface
 */
export const ReferralApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReferralApiAxiosParamCreator(configuration)
    return {
        /**
         * Get or generate user\'s referral code
         * @summary Get referral code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async referralCodeGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHandlersReferralCodeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.referralCodeGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReferralApi.referralCodeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get referral statistics (total referrals, earnings, list)
         * @summary Get referral stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async referralStatsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParierServerInternalServiceReferralStatsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.referralStatsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReferralApi.referralStatsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReferralApi - factory interface
 */
export const ReferralApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReferralApiFp(configuration)
    return {
        /**
         * Get or generate user\'s referral code
         * @summary Get referral code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referralCodeGet(options?: RawAxiosRequestConfig): AxiosPromise<InternalHandlersReferralCodeResponse> {
            return localVarFp.referralCodeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get referral statistics (total referrals, earnings, list)
         * @summary Get referral stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referralStatsGet(options?: RawAxiosRequestConfig): AxiosPromise<ParierServerInternalServiceReferralStatsResponse> {
            return localVarFp.referralStatsGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReferralApi - object-oriented interface
 */
export class ReferralApi extends BaseAPI {
    /**
     * Get or generate user\'s referral code
     * @summary Get referral code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public referralCodeGet(options?: RawAxiosRequestConfig) {
        return ReferralApiFp(this.configuration).referralCodeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get referral statistics (total referrals, earnings, list)
     * @summary Get referral stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public referralStatsGet(options?: RawAxiosRequestConfig) {
        return ReferralApiFp(this.configuration).referralStatsGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WalletApi - axios parameter creator
 */
export const WalletApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get wallet balance
         * @summary Get wallet balance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletBalanceGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/wallet/balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deposit to wallet
         * @summary Deposit to wallet
         * @param {InternalHandlersDepositRequest} request Deposit request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletDepositPost: async (request: InternalHandlersDepositRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('walletDepositPost', 'request', request)
            const localVarPath = `/wallet/deposit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get wallet transactions
         * @summary Get wallet transactions
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletTransactionsGet: async (offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/wallet/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Withdraw from wallet
         * @summary Withdraw from wallet
         * @param {InternalHandlersWithdrawRequest} request Withdraw request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletWithdrawPost: async (request: InternalHandlersWithdrawRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('walletWithdrawPost', 'request', request)
            const localVarPath = `/wallet/withdraw`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WalletApi - functional programming interface
 */
export const WalletApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WalletApiAxiosParamCreator(configuration)
    return {
        /**
         * Get wallet balance
         * @summary Get wallet balance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletBalanceGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHandlersBalanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.walletBalanceGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletApi.walletBalanceGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deposit to wallet
         * @summary Deposit to wallet
         * @param {InternalHandlersDepositRequest} request Deposit request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletDepositPost(request: InternalHandlersDepositRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHandlersBalanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.walletDepositPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletApi.walletDepositPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get wallet transactions
         * @summary Get wallet transactions
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletTransactionsGet(offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHandlersTransactionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.walletTransactionsGet(offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletApi.walletTransactionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Withdraw from wallet
         * @summary Withdraw from wallet
         * @param {InternalHandlersWithdrawRequest} request Withdraw request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletWithdrawPost(request: InternalHandlersWithdrawRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHandlersBalanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.walletWithdrawPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletApi.walletWithdrawPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WalletApi - factory interface
 */
export const WalletApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WalletApiFp(configuration)
    return {
        /**
         * Get wallet balance
         * @summary Get wallet balance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletBalanceGet(options?: RawAxiosRequestConfig): AxiosPromise<InternalHandlersBalanceResponse> {
            return localVarFp.walletBalanceGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Deposit to wallet
         * @summary Deposit to wallet
         * @param {InternalHandlersDepositRequest} request Deposit request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletDepositPost(request: InternalHandlersDepositRequest, options?: RawAxiosRequestConfig): AxiosPromise<InternalHandlersBalanceResponse> {
            return localVarFp.walletDepositPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Get wallet transactions
         * @summary Get wallet transactions
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletTransactionsGet(offset?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<InternalHandlersTransactionsResponse> {
            return localVarFp.walletTransactionsGet(offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Withdraw from wallet
         * @summary Withdraw from wallet
         * @param {InternalHandlersWithdrawRequest} request Withdraw request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletWithdrawPost(request: InternalHandlersWithdrawRequest, options?: RawAxiosRequestConfig): AxiosPromise<InternalHandlersBalanceResponse> {
            return localVarFp.walletWithdrawPost(request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WalletApi - object-oriented interface
 */
export class WalletApi extends BaseAPI {
    /**
     * Get wallet balance
     * @summary Get wallet balance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public walletBalanceGet(options?: RawAxiosRequestConfig) {
        return WalletApiFp(this.configuration).walletBalanceGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deposit to wallet
     * @summary Deposit to wallet
     * @param {InternalHandlersDepositRequest} request Deposit request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public walletDepositPost(request: InternalHandlersDepositRequest, options?: RawAxiosRequestConfig) {
        return WalletApiFp(this.configuration).walletDepositPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get wallet transactions
     * @summary Get wallet transactions
     * @param {number} [offset] Offset
     * @param {number} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public walletTransactionsGet(offset?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return WalletApiFp(this.configuration).walletTransactionsGet(offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Withdraw from wallet
     * @summary Withdraw from wallet
     * @param {InternalHandlersWithdrawRequest} request Withdraw request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public walletWithdrawPost(request: InternalHandlersWithdrawRequest, options?: RawAxiosRequestConfig) {
        return WalletApiFp(this.configuration).walletWithdrawPost(request, options).then((request) => request(this.axios, this.basePath));
    }
}




/* tslint:disable */
/* eslint-disable */
/**
 * Oasix API
 * This is the Oasix property management system API server.
 *
 * The version of the OpenAPI document: 1.0
 * Contact: support@swagger.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface InternalHandlersBetCreateResponse {
    'data'?: ParierServerInternalModelsBetResponse;
    'message'?: string;
    'success'?: boolean;
}
export interface InternalHandlersBetResponse {
    'count'?: number;
    'data'?: Array<ParierServerInternalModelsBetResponse>;
    'success'?: boolean;
    'total'?: number;
}
export interface InternalHandlersDictionaryResponse {
    'data'?: Array<ParierServerInternalModelsDictionaryItemString>;
    'message'?: string;
    'success'?: boolean;
}
export interface InternalHandlersKeycloakLogoutRequest {
    'realm'?: string;
    'refresh_token'?: string;
}
export interface InternalHandlersLoginCodeRequest {
    'code': string;
    'iss': string;
    'redirect_uri': string;
}
export interface InternalHandlersMediaResponse {
    'content_type'?: string;
    'id'?: string;
    'name'?: string;
    'type_id'?: string;
    'type_name'?: string;
    'url'?: string;
}
export interface InternalHandlersProfileResponse {
    'created_at'?: string;
    'email'?: string;
    'expires_at'?: string;
    'id'?: string;
    'phone'?: string;
    'realm'?: string;
    'roles'?: Array<string>;
    'updated_at'?: string;
    'user_id'?: string;
    'username'?: string;
}
export interface InternalHandlersPropertiesEnumResponse {
    'description'?: string;
    'id'?: string;
    'name'?: string;
    'property'?: string;
    'property_type'?: ParierServerInternalModelsPropertyType;
    'value'?: object;
    'value_id'?: string;
}


export interface InternalHandlersPropertiesEnumsResponse {
    'data'?: Array<InternalHandlersPropertiesEnumResponse>;
    'total'?: number;
}
export interface InternalHandlersPropertiesTypeResponse {
    'description'?: string;
    'id'?: string;
    'name'?: string;
    'place'?: ParierServerInternalModelsPropertyPlace;
    'type'?: ParierServerInternalModelsPropertyType;
}


export interface InternalHandlersPropertiesTypesResponse {
    'data'?: Array<InternalHandlersPropertiesTypeResponse>;
    'total'?: number;
}
export interface ParierServerInternalModelsBetCreateRequest {
    'amount'?: string;
    'category_id'?: string;
    'coefficient'?: string;
    'deadline'?: string;
    'description'?: string;
    'language'?: string;
    'status_id'?: string;
    'title'?: string;
    'type_id'?: string;
    'user'?: ParierServerInternalModelsUser;
    'verification_source_id'?: Array<string>;
}
export interface ParierServerInternalModelsBetRequest {
    'category_id'?: string;
    'coefficient'?: string;
    'deadline'?: string;
    'description'?: string;
    'language'?: string;
    'limit'?: number;
    'max_amount'?: string;
    'min_amount'?: string;
    'offset'?: number;
    'sort_by'?: string;
    'sort_dir'?: string;
    'status_id'?: string;
    'title'?: string;
    'type_id'?: string;
    'user'?: ParierServerInternalModelsUser;
    'verification_source_id'?: Array<string>;
}
export interface ParierServerInternalModelsBetResponse {
    'amount'?: number;
    'category_id'?: string;
    'category_name'?: string;
    'coefficient'?: number;
    'created_at'?: string;
    'deadline'?: string;
    'deleted_at'?: string;
    'description'?: string;
    'id'?: string;
    'is_liked_by_me'?: boolean;
    'status_id'?: string;
    'status_name'?: string;
    'title'?: string;
    'type_id'?: string;
    'type_name'?: string;
    'updated_at'?: string;
    'verification_sources'?: Array<ParierServerInternalModelsVerificationSourceResponse>;
}
export interface ParierServerInternalModelsDefaultRequest {
    'language'?: string;
    'user'?: ParierServerInternalModelsUser;
}
export interface ParierServerInternalModelsDictionaryItemString {
    'description'?: string;
    'id'?: string;
    'name'?: string;
}
export interface ParierServerInternalModelsDictionaryRequest {
    'language'?: string;
    'search'?: string;
    'user'?: ParierServerInternalModelsUser;
}
export interface ParierServerInternalModelsErrorResponse {
    'details'?: string;
    'error'?: string;
    'success'?: boolean;
}

export const ParierServerInternalModelsPropertyPlace = {
    PropertyPlaceAgent: 'AGENT',
    PropertyPlaceUnit: 'UNIT',
    PropertyPlaceUser: 'USER'
} as const;

export type ParierServerInternalModelsPropertyPlace = typeof ParierServerInternalModelsPropertyPlace[keyof typeof ParierServerInternalModelsPropertyPlace];



export const ParierServerInternalModelsPropertyType = {
    PropertyTypeDate: 'DATE',
    PropertyTypeDecimal: 'DECIMAL',
    PropertyTypeInteger: 'INTEGER',
    PropertyTypeLocalization: 'LOCALIZATION',
    PropertyTypeBoolean: 'BOOLEAN',
    PropertyTypeText: 'TEXT',
    PropertyTypeJSONObject: 'JSONOBJECT',
    PropertyTypeJSONArray: 'JSONARRAY',
    PropertyTypeMedia: 'MEDIA',
    PropertyTypeEnum: 'ENUM'
} as const;

export type ParierServerInternalModelsPropertyType = typeof ParierServerInternalModelsPropertyType[keyof typeof ParierServerInternalModelsPropertyType];


export interface ParierServerInternalModelsSuccessResponse {
    'data'?: object;
    'message'?: string;
    'success'?: boolean;
}
export interface ParierServerInternalModelsUser {
    'data'?: { [key: string]: any; };
    'email'?: string;
    'external_id'?: string;
    'id'?: string;
    'phone'?: string;
    'realm'?: string;
    'roles'?: Array<string>;
    'session_id'?: string;
    'username'?: string;
}
export interface ParierServerInternalModelsVerificationSourceResponse {
    'id'?: string;
    'name'?: string;
}
export interface ParierServerInternalRepositoryPropertiesEnumFilter {
    'language'?: string;
    'limit'?: number;
    'offset'?: number;
    'property_type'?: string;
    'search'?: string;
    'sort_by'?: string;
    'sort_dir'?: string;
    'user'?: ParierServerInternalModelsUser;
}
export interface ParierServerInternalRepositoryPropertiesTypeFilter {
    'group'?: string;
    'language'?: string;
    'limit'?: number;
    'offset'?: number;
    'place'?: ParierServerInternalModelsPropertyPlace;
    'search'?: string;
    'sort_by'?: string;
    'sort_dir'?: string;
    'user'?: ParierServerInternalModelsUser;
}



/**
 * AuthApi - axios parameter creator
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authenticate user through Keycloak and return tokens
         * @summary Login via Keycloak
         * @param {InternalHandlersLoginCodeRequest} credentials Login credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginCodePut: async (credentials: InternalHandlersLoginCodeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'credentials' is not null or undefined
            assertParamExists('authLoginCodePut', 'credentials', credentials)
            const localVarPath = `/auth/login-code`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(credentials, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Logout user from Keycloak
         * @summary Logout user
         * @param {InternalHandlersKeycloakLogoutRequest} request Logout parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogoutPut: async (request: InternalHandlersKeycloakLogoutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('authLogoutPut', 'request', request)
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current user profile information from Keycloak
         * @summary Get current user profile
         * @param {ParierServerInternalModelsDefaultRequest} request Profile parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authProfilePost: async (request: ParierServerInternalModelsDefaultRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('authProfilePost', 'request', request)
            const localVarPath = `/auth/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Authenticate user through Keycloak and return tokens
         * @summary Login via Keycloak
         * @param {InternalHandlersLoginCodeRequest} credentials Login credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLoginCodePut(credentials: InternalHandlersLoginCodeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHandlersProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLoginCodePut(credentials, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authLoginCodePut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Logout user from Keycloak
         * @summary Logout user
         * @param {InternalHandlersKeycloakLogoutRequest} request Logout parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLogoutPut(request: InternalHandlersKeycloakLogoutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParierServerInternalModelsSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLogoutPut(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authLogoutPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current user profile information from Keycloak
         * @summary Get current user profile
         * @param {ParierServerInternalModelsDefaultRequest} request Profile parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authProfilePost(request: ParierServerInternalModelsDefaultRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHandlersProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authProfilePost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authProfilePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Authenticate user through Keycloak and return tokens
         * @summary Login via Keycloak
         * @param {InternalHandlersLoginCodeRequest} credentials Login credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginCodePut(credentials: InternalHandlersLoginCodeRequest, options?: RawAxiosRequestConfig): AxiosPromise<InternalHandlersProfileResponse> {
            return localVarFp.authLoginCodePut(credentials, options).then((request) => request(axios, basePath));
        },
        /**
         * Logout user from Keycloak
         * @summary Logout user
         * @param {InternalHandlersKeycloakLogoutRequest} request Logout parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogoutPut(request: InternalHandlersKeycloakLogoutRequest, options?: RawAxiosRequestConfig): AxiosPromise<ParierServerInternalModelsSuccessResponse> {
            return localVarFp.authLogoutPut(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current user profile information from Keycloak
         * @summary Get current user profile
         * @param {ParierServerInternalModelsDefaultRequest} request Profile parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authProfilePost(request: ParierServerInternalModelsDefaultRequest, options?: RawAxiosRequestConfig): AxiosPromise<InternalHandlersProfileResponse> {
            return localVarFp.authProfilePost(request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 */
export class AuthApi extends BaseAPI {
    /**
     * Authenticate user through Keycloak and return tokens
     * @summary Login via Keycloak
     * @param {InternalHandlersLoginCodeRequest} credentials Login credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authLoginCodePut(credentials: InternalHandlersLoginCodeRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authLoginCodePut(credentials, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Logout user from Keycloak
     * @summary Logout user
     * @param {InternalHandlersKeycloakLogoutRequest} request Logout parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authLogoutPut(request: InternalHandlersKeycloakLogoutRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authLogoutPut(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current user profile information from Keycloak
     * @summary Get current user profile
     * @param {ParierServerInternalModelsDefaultRequest} request Profile parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authProfilePost(request: ParierServerInternalModelsDefaultRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authProfilePost(request, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CoreApi - axios parameter creator
 */
export const CoreApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get locales
         * @summary Get locales
         * @param {string} lang Language
         * @param {string} ns Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreLocalesLangNsGet: async (lang: string, ns: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lang' is not null or undefined
            assertParamExists('coreLocalesLangNsGet', 'lang', lang)
            // verify required parameter 'ns' is not null or undefined
            assertParamExists('coreLocalesLangNsGet', 'ns', ns)
            const localVarPath = `/core/locales/{lang}/{ns}`
                .replace(`{${"lang"}}`, encodeURIComponent(String(lang)))
                .replace(`{${"ns"}}`, encodeURIComponent(String(ns)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get properties enums
         * @summary Get properties enums
         * @param {ParierServerInternalRepositoryPropertiesEnumFilter} filter Filter parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        corePropertiesEnumsPost: async (filter: ParierServerInternalRepositoryPropertiesEnumFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('corePropertiesEnumsPost', 'filter', filter)
            const localVarPath = `/core/properties-enums`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get properties type by id
         * @summary Get properties type by id
         * @param {string} id Properties type id
         * @param {ParierServerInternalModelsDefaultRequest} filter Filter parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        corePropertiesTypesIdPost: async (id: string, filter: ParierServerInternalModelsDefaultRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('corePropertiesTypesIdPost', 'id', id)
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('corePropertiesTypesIdPost', 'filter', filter)
            const localVarPath = `/core/properties-types/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get paginated list of properties types with filtering
         * @summary Get paginated list of properties types
         * @param {ParierServerInternalRepositoryPropertiesTypeFilter} filter Filter parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        corePropertiesTypesPost: async (filter: ParierServerInternalRepositoryPropertiesTypeFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('corePropertiesTypesPost', 'filter', filter)
            const localVarPath = `/core/properties-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoreApi - functional programming interface
 */
export const CoreApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CoreApiAxiosParamCreator(configuration)
    return {
        /**
         * Get locales
         * @summary Get locales
         * @param {string} lang Language
         * @param {string} ns Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coreLocalesLangNsGet(lang: string, ns: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coreLocalesLangNsGet(lang, ns, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreApi.coreLocalesLangNsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get properties enums
         * @summary Get properties enums
         * @param {ParierServerInternalRepositoryPropertiesEnumFilter} filter Filter parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async corePropertiesEnumsPost(filter: ParierServerInternalRepositoryPropertiesEnumFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHandlersPropertiesEnumsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.corePropertiesEnumsPost(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreApi.corePropertiesEnumsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get properties type by id
         * @summary Get properties type by id
         * @param {string} id Properties type id
         * @param {ParierServerInternalModelsDefaultRequest} filter Filter parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async corePropertiesTypesIdPost(id: string, filter: ParierServerInternalModelsDefaultRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHandlersPropertiesTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.corePropertiesTypesIdPost(id, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreApi.corePropertiesTypesIdPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get paginated list of properties types with filtering
         * @summary Get paginated list of properties types
         * @param {ParierServerInternalRepositoryPropertiesTypeFilter} filter Filter parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async corePropertiesTypesPost(filter: ParierServerInternalRepositoryPropertiesTypeFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHandlersPropertiesTypesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.corePropertiesTypesPost(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreApi.corePropertiesTypesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CoreApi - factory interface
 */
export const CoreApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CoreApiFp(configuration)
    return {
        /**
         * Get locales
         * @summary Get locales
         * @param {string} lang Language
         * @param {string} ns Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreLocalesLangNsGet(lang: string, ns: string, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.coreLocalesLangNsGet(lang, ns, options).then((request) => request(axios, basePath));
        },
        /**
         * Get properties enums
         * @summary Get properties enums
         * @param {ParierServerInternalRepositoryPropertiesEnumFilter} filter Filter parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        corePropertiesEnumsPost(filter: ParierServerInternalRepositoryPropertiesEnumFilter, options?: RawAxiosRequestConfig): AxiosPromise<InternalHandlersPropertiesEnumsResponse> {
            return localVarFp.corePropertiesEnumsPost(filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Get properties type by id
         * @summary Get properties type by id
         * @param {string} id Properties type id
         * @param {ParierServerInternalModelsDefaultRequest} filter Filter parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        corePropertiesTypesIdPost(id: string, filter: ParierServerInternalModelsDefaultRequest, options?: RawAxiosRequestConfig): AxiosPromise<InternalHandlersPropertiesTypeResponse> {
            return localVarFp.corePropertiesTypesIdPost(id, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Get paginated list of properties types with filtering
         * @summary Get paginated list of properties types
         * @param {ParierServerInternalRepositoryPropertiesTypeFilter} filter Filter parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        corePropertiesTypesPost(filter: ParierServerInternalRepositoryPropertiesTypeFilter, options?: RawAxiosRequestConfig): AxiosPromise<InternalHandlersPropertiesTypesResponse> {
            return localVarFp.corePropertiesTypesPost(filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CoreApi - object-oriented interface
 */
export class CoreApi extends BaseAPI {
    /**
     * Get locales
     * @summary Get locales
     * @param {string} lang Language
     * @param {string} ns Namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coreLocalesLangNsGet(lang: string, ns: string, options?: RawAxiosRequestConfig) {
        return CoreApiFp(this.configuration).coreLocalesLangNsGet(lang, ns, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get properties enums
     * @summary Get properties enums
     * @param {ParierServerInternalRepositoryPropertiesEnumFilter} filter Filter parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public corePropertiesEnumsPost(filter: ParierServerInternalRepositoryPropertiesEnumFilter, options?: RawAxiosRequestConfig) {
        return CoreApiFp(this.configuration).corePropertiesEnumsPost(filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get properties type by id
     * @summary Get properties type by id
     * @param {string} id Properties type id
     * @param {ParierServerInternalModelsDefaultRequest} filter Filter parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public corePropertiesTypesIdPost(id: string, filter: ParierServerInternalModelsDefaultRequest, options?: RawAxiosRequestConfig) {
        return CoreApiFp(this.configuration).corePropertiesTypesIdPost(id, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get paginated list of properties types with filtering
     * @summary Get paginated list of properties types
     * @param {ParierServerInternalRepositoryPropertiesTypeFilter} filter Filter parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public corePropertiesTypesPost(filter: ParierServerInternalRepositoryPropertiesTypeFilter, options?: RawAxiosRequestConfig) {
        return CoreApiFp(this.configuration).corePropertiesTypesPost(filter, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MediaApi - axios parameter creator
 */
export const MediaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Download a file from S3 storage
         * @summary Download file
         * @param {string} id Media ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaIdDownloadGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('mediaIdDownloadGet', 'id', id)
            const localVarPath = `/media/{id}/download`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get media file information
         * @summary Get media info
         * @param {string} id Media ID
         * @param {ParierServerInternalModelsDefaultRequest} request Get media parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaIdPost: async (id: string, request: ParierServerInternalModelsDefaultRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('mediaIdPost', 'id', id)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('mediaIdPost', 'request', request)
            const localVarPath = `/media/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Raw a file from S3 storage
         * @summary Raw file
         * @param {string} id Media ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaIdRawGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('mediaIdRawGet', 'id', id)
            const localVarPath = `/media/{id}/raw`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MediaApi - functional programming interface
 */
export const MediaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MediaApiAxiosParamCreator(configuration)
    return {
        /**
         * Download a file from S3 storage
         * @summary Download file
         * @param {string} id Media ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mediaIdDownloadGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mediaIdDownloadGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.mediaIdDownloadGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get media file information
         * @summary Get media info
         * @param {string} id Media ID
         * @param {ParierServerInternalModelsDefaultRequest} request Get media parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mediaIdPost(id: string, request: ParierServerInternalModelsDefaultRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHandlersMediaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mediaIdPost(id, request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.mediaIdPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Raw a file from S3 storage
         * @summary Raw file
         * @param {string} id Media ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mediaIdRawGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mediaIdRawGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.mediaIdRawGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MediaApi - factory interface
 */
export const MediaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MediaApiFp(configuration)
    return {
        /**
         * Download a file from S3 storage
         * @summary Download file
         * @param {string} id Media ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaIdDownloadGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.mediaIdDownloadGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get media file information
         * @summary Get media info
         * @param {string} id Media ID
         * @param {ParierServerInternalModelsDefaultRequest} request Get media parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaIdPost(id: string, request: ParierServerInternalModelsDefaultRequest, options?: RawAxiosRequestConfig): AxiosPromise<InternalHandlersMediaResponse> {
            return localVarFp.mediaIdPost(id, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Raw a file from S3 storage
         * @summary Raw file
         * @param {string} id Media ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaIdRawGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.mediaIdRawGet(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MediaApi - object-oriented interface
 */
export class MediaApi extends BaseAPI {
    /**
     * Download a file from S3 storage
     * @summary Download file
     * @param {string} id Media ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mediaIdDownloadGet(id: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).mediaIdDownloadGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get media file information
     * @summary Get media info
     * @param {string} id Media ID
     * @param {ParierServerInternalModelsDefaultRequest} request Get media parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mediaIdPost(id: string, request: ParierServerInternalModelsDefaultRequest, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).mediaIdPost(id, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Raw a file from S3 storage
     * @summary Raw file
     * @param {string} id Media ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mediaIdRawGet(id: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).mediaIdRawGet(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ParierApi - axios parameter creator
 */
export const ParierApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get bets
         * @summary Get bets
         * @param {ParierServerInternalModelsBetRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parierBetPost: async (request: ParierServerInternalModelsBetRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('parierBetPost', 'request', request)
            const localVarPath = `/parier/bet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create bet
         * @summary Create bet
         * @param {ParierServerInternalModelsBetCreateRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parierBetPut: async (request: ParierServerInternalModelsBetCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('parierBetPut', 'request', request)
            const localVarPath = `/parier/bet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get bet statuses
         * @summary Get bet statuses
         * @param {ParierServerInternalModelsDictionaryRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parierBetStatusesPost: async (request: ParierServerInternalModelsDictionaryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('parierBetStatusesPost', 'request', request)
            const localVarPath = `/parier/bet-statuses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get bet types
         * @summary Get bet types
         * @param {ParierServerInternalModelsDictionaryRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parierBetTypesPost: async (request: ParierServerInternalModelsDictionaryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('parierBetTypesPost', 'request', request)
            const localVarPath = `/parier/bet-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get categories
         * @summary Get categories
         * @param {ParierServerInternalModelsDictionaryRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parierCategoriesPost: async (request: ParierServerInternalModelsDictionaryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('parierCategoriesPost', 'request', request)
            const localVarPath = `/parier/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get like types
         * @summary Get like types
         * @param {ParierServerInternalModelsDictionaryRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parierLikeTypesPost: async (request: ParierServerInternalModelsDictionaryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('parierLikeTypesPost', 'request', request)
            const localVarPath = `/parier/like-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get verification sources
         * @summary Get verification sources
         * @param {ParierServerInternalModelsDictionaryRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parierVerificationSourcesPost: async (request: ParierServerInternalModelsDictionaryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('parierVerificationSourcesPost', 'request', request)
            const localVarPath = `/parier/verification-sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Keycloak required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Keycloak", [], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ParierApi - functional programming interface
 */
export const ParierApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ParierApiAxiosParamCreator(configuration)
    return {
        /**
         * Get bets
         * @summary Get bets
         * @param {ParierServerInternalModelsBetRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parierBetPost(request: ParierServerInternalModelsBetRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHandlersBetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.parierBetPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParierApi.parierBetPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create bet
         * @summary Create bet
         * @param {ParierServerInternalModelsBetCreateRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parierBetPut(request: ParierServerInternalModelsBetCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHandlersBetCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.parierBetPut(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParierApi.parierBetPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get bet statuses
         * @summary Get bet statuses
         * @param {ParierServerInternalModelsDictionaryRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parierBetStatusesPost(request: ParierServerInternalModelsDictionaryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHandlersDictionaryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.parierBetStatusesPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParierApi.parierBetStatusesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get bet types
         * @summary Get bet types
         * @param {ParierServerInternalModelsDictionaryRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parierBetTypesPost(request: ParierServerInternalModelsDictionaryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHandlersDictionaryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.parierBetTypesPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParierApi.parierBetTypesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get categories
         * @summary Get categories
         * @param {ParierServerInternalModelsDictionaryRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parierCategoriesPost(request: ParierServerInternalModelsDictionaryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHandlersDictionaryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.parierCategoriesPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParierApi.parierCategoriesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get like types
         * @summary Get like types
         * @param {ParierServerInternalModelsDictionaryRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parierLikeTypesPost(request: ParierServerInternalModelsDictionaryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHandlersDictionaryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.parierLikeTypesPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParierApi.parierLikeTypesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get verification sources
         * @summary Get verification sources
         * @param {ParierServerInternalModelsDictionaryRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parierVerificationSourcesPost(request: ParierServerInternalModelsDictionaryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHandlersDictionaryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.parierVerificationSourcesPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParierApi.parierVerificationSourcesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ParierApi - factory interface
 */
export const ParierApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ParierApiFp(configuration)
    return {
        /**
         * Get bets
         * @summary Get bets
         * @param {ParierServerInternalModelsBetRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parierBetPost(request: ParierServerInternalModelsBetRequest, options?: RawAxiosRequestConfig): AxiosPromise<InternalHandlersBetResponse> {
            return localVarFp.parierBetPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Create bet
         * @summary Create bet
         * @param {ParierServerInternalModelsBetCreateRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parierBetPut(request: ParierServerInternalModelsBetCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<InternalHandlersBetCreateResponse> {
            return localVarFp.parierBetPut(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Get bet statuses
         * @summary Get bet statuses
         * @param {ParierServerInternalModelsDictionaryRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parierBetStatusesPost(request: ParierServerInternalModelsDictionaryRequest, options?: RawAxiosRequestConfig): AxiosPromise<InternalHandlersDictionaryResponse> {
            return localVarFp.parierBetStatusesPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Get bet types
         * @summary Get bet types
         * @param {ParierServerInternalModelsDictionaryRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parierBetTypesPost(request: ParierServerInternalModelsDictionaryRequest, options?: RawAxiosRequestConfig): AxiosPromise<InternalHandlersDictionaryResponse> {
            return localVarFp.parierBetTypesPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Get categories
         * @summary Get categories
         * @param {ParierServerInternalModelsDictionaryRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parierCategoriesPost(request: ParierServerInternalModelsDictionaryRequest, options?: RawAxiosRequestConfig): AxiosPromise<InternalHandlersDictionaryResponse> {
            return localVarFp.parierCategoriesPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Get like types
         * @summary Get like types
         * @param {ParierServerInternalModelsDictionaryRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parierLikeTypesPost(request: ParierServerInternalModelsDictionaryRequest, options?: RawAxiosRequestConfig): AxiosPromise<InternalHandlersDictionaryResponse> {
            return localVarFp.parierLikeTypesPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Get verification sources
         * @summary Get verification sources
         * @param {ParierServerInternalModelsDictionaryRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parierVerificationSourcesPost(request: ParierServerInternalModelsDictionaryRequest, options?: RawAxiosRequestConfig): AxiosPromise<InternalHandlersDictionaryResponse> {
            return localVarFp.parierVerificationSourcesPost(request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ParierApi - object-oriented interface
 */
export class ParierApi extends BaseAPI {
    /**
     * Get bets
     * @summary Get bets
     * @param {ParierServerInternalModelsBetRequest} request Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public parierBetPost(request: ParierServerInternalModelsBetRequest, options?: RawAxiosRequestConfig) {
        return ParierApiFp(this.configuration).parierBetPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create bet
     * @summary Create bet
     * @param {ParierServerInternalModelsBetCreateRequest} request Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public parierBetPut(request: ParierServerInternalModelsBetCreateRequest, options?: RawAxiosRequestConfig) {
        return ParierApiFp(this.configuration).parierBetPut(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get bet statuses
     * @summary Get bet statuses
     * @param {ParierServerInternalModelsDictionaryRequest} request Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public parierBetStatusesPost(request: ParierServerInternalModelsDictionaryRequest, options?: RawAxiosRequestConfig) {
        return ParierApiFp(this.configuration).parierBetStatusesPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get bet types
     * @summary Get bet types
     * @param {ParierServerInternalModelsDictionaryRequest} request Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public parierBetTypesPost(request: ParierServerInternalModelsDictionaryRequest, options?: RawAxiosRequestConfig) {
        return ParierApiFp(this.configuration).parierBetTypesPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get categories
     * @summary Get categories
     * @param {ParierServerInternalModelsDictionaryRequest} request Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public parierCategoriesPost(request: ParierServerInternalModelsDictionaryRequest, options?: RawAxiosRequestConfig) {
        return ParierApiFp(this.configuration).parierCategoriesPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get like types
     * @summary Get like types
     * @param {ParierServerInternalModelsDictionaryRequest} request Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public parierLikeTypesPost(request: ParierServerInternalModelsDictionaryRequest, options?: RawAxiosRequestConfig) {
        return ParierApiFp(this.configuration).parierLikeTypesPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get verification sources
     * @summary Get verification sources
     * @param {ParierServerInternalModelsDictionaryRequest} request Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public parierVerificationSourcesPost(request: ParierServerInternalModelsDictionaryRequest, options?: RawAxiosRequestConfig) {
        return ParierApiFp(this.configuration).parierVerificationSourcesPost(request, options).then((request) => request(this.axios, this.basePath));
    }
}




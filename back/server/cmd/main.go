package main

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"parier-server/internal/config"
	"parier-server/internal/models"
	"parier-server/internal/routes"

	_ "parier-server/docs" // This will be generated by swag

	"gorm.io/driver/postgres"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
)

// @title Oasix API
// @version 1.0
// @description This is the Oasix property management system API server.
// @termsOfService http://swagger.io/terms/

// @contact.name API Support
// @contact.url http://www.swagger.io/support
// @contact.email support@swagger.io

// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html

// @host localhost:8080
// @BasePath /api/v1

// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
// @description Type "Bearer" followed by a space and JWT token.

// @securityDefinitions.basic BasicAuth

//	@securitydefinitions.oauth2.implicit	OAuth2Keycloak
//	@authorizationUrl						http://localhost:18080/realms/parier/protocol/openid-connect/auth
//	@scope.read_access						Grants read access
//	@scope.write_access						Grants write access

func main() {
	// Load configuration
	cfg := config.LoadConfig()

	// Setup logger
	var gormLogger logger.Interface
	switch cfg.Database.LogLevel {
	case "SILENT":
		gormLogger = logger.Default.LogMode(logger.Silent)
	case "ERROR":
		gormLogger = logger.Default.LogMode(logger.Error)
	case "WARN":
		gormLogger = logger.Default.LogMode(logger.Warn)
	case "INFO":
		gormLogger = logger.Default.LogMode(logger.Info)
	default:
		gormLogger = logger.Default.LogMode(logger.Silent)
	}

	// Connect to database
	db, err := connectDatabase(cfg, gormLogger)
	if err != nil {
		log.Fatalf("Failed to connect to database: %v", err)
	}

	if cfg.Database.Migration {
		// Auto migrate database schema
		if err := migrateDatabase(db); err != nil {
			log.Fatalf("Failed to migrate database: %v", err)
		}
	}

	// Setup routes
	router := routes.SetupRoutes(cfg, db)

	// Create HTTP server
	srv := &http.Server{
		Addr:           ":" + cfg.Server.Port,
		Handler:        router,
		ReadTimeout:    time.Duration(cfg.Server.ReadTimeout) * time.Second,
		WriteTimeout:   time.Duration(cfg.Server.WriteTimeout) * time.Second,
		MaxHeaderBytes: 1 << 20,
	}

	// Start server in a goroutine
	go func() {
		log.Printf("Starting server on port %s", cfg.Server.Port)
		log.Printf("Swagger documentation available at: http://localhost:%s/swagger/index.html", cfg.Server.Port)
		if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Fatalf("Failed to start server: %v", err)
		}
	}()

	// Wait for interrupt signal to gracefully shutdown the server
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit
	log.Println("Shutting down server...")

	// The context is used to inform the server it has 5 seconds to finish
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	if err := srv.Shutdown(ctx); err != nil {
		log.Fatal("Server forced to shutdown:", err)
	}

	log.Println("Server exited")
}

// connectDatabase establishes connection to PostgreSQL database
func connectDatabase(cfg *config.Config, gormLogger logger.Interface) (*gorm.DB, error) {
	dsn := cfg.Database.GetDSN()

	db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{
		Logger: gormLogger,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to connect to database: %w", err)
	}

	// Configure connection pool
	sqlDB, err := db.DB()
	if err != nil {
		return nil, fmt.Errorf("failed to get database instance: %w", err)
	}

	sqlDB.SetMaxIdleConns(10)
	sqlDB.SetMaxOpenConns(100)
	sqlDB.SetConnMaxLifetime(time.Hour)

	// Test connection
	if err := sqlDB.Ping(); err != nil {
		return nil, fmt.Errorf("failed to ping database: %w", err)
	}

	log.Println("Successfully connected to database")
	return db, nil
}

// migrateDatabase runs auto migration for all models
func migrateDatabase(db *gorm.DB) error {
	log.Println("Running database migration...")

	// Enable UUID extension (PostgreSQL specific)
	if err := db.Exec("CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\"").Error; err != nil {
		log.Printf("Warning: Failed to create uuid-ossp extension: %v", err)
	}

	// Enable PostGIS extension (PostgreSQL specific)
	if err := db.Exec("CREATE EXTENSION IF NOT EXISTS postgis").Error; err != nil {
		log.Printf("Warning: Failed to create postgis extension: %v", err)
	}

	// List of models to migrate in dependency order
	models := []interface{}{
		// Core localization models
		&models.TLWord{},
		&models.TDLang{},
		&models.TLocalization{},
		&models.TDPropertiesType{},

		// User & Role models
		&models.TDRole{},
		&models.TUser{},
		&models.TUserRole{},
		&models.TDTableRole{},
		&models.TPropertiesRole{},
		&models.TUserProperties{},

		// Media models
		&models.TDMedia{},
		&models.TMedia{},

		// Referral models
		&models.TReferralCode{},
		&models.TReferral{},
		&models.TReferralEarning{},
	}

	for _, model := range models {
		if err := db.AutoMigrate(model); err != nil {
			return fmt.Errorf("failed to migrate model %T: %w", model, err)
		}
	}

	log.Println("Database migration completed successfully")
	return nil
}
